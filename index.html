<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Split the G</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #0d0d0d;
            color: #e0d6c2;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* ════════════════════════════════════════
           SCREENS
           ════════════════════════════════════════ */
        .screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 24px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        .screen.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* ════════════════════════════════════════
           START SCREEN
           ════════════════════════════════════════ */
        .title {
            font-size: 2.5rem;
            font-weight: 800;
            color: #c8a84e;
            letter-spacing: 0.04em;
        }
        .subtitle {
            font-size: 0.8rem;
            color: #7a6a4a;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 40px;
        }
        .instructions {
            line-height: 2.2;
            font-size: 0.95rem;
            color: #a09080;
            margin-bottom: 40px;
            text-align: left;
        }
        .instructions span {
            color: #c8a84e;
            font-weight: 700;
        }
        .sensor-info {
            margin-top: 24px;
            font-size: 0.7rem;
            color: #504838;
        }

        /* ════════════════════════════════════════
           BUTTONS
           ════════════════════════════════════════ */
        .btn {
            padding: 16px 52px;
            font-size: 1.05rem;
            font-weight: 700;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 0.1em;
            transition: transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active { transform: scale(0.95); }

        .btn-primary {
            background: linear-gradient(135deg, #d4b050, #a08030);
            color: #1a1408;
            box-shadow: 0 4px 24px rgba(200, 168, 78, 0.25);
        }
        .btn-stop {
            background: transparent;
            border: 2px solid rgba(200, 168, 78, 0.5);
            color: #c8a84e;
            padding: 14px 44px;
            font-size: 0.95rem;
        }

        /* ════════════════════════════════════════
           GAME SCREEN
           ════════════════════════════════════════ */
        #screen-game {
            justify-content: flex-start;
            padding-top: 20px;
            padding-bottom: 30px;
        }

        .hud {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 32px;
            font-size: 0.8rem;
            color: #7a6a4a;
            font-variant-numeric: tabular-nums;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        .hud-val { color: #c8a84e; font-weight: 600; }

        .pour-indicator {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.25em;
            color: #c8a84e;
            height: 20px;
            opacity: 0;
            transition: opacity 0.15s;
            flex-shrink: 0;
        }
        .pour-indicator.visible { opacity: 1; }

        .glass-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            min-height: 0;
        }

        /* ─── THE GLASS ─── */
        .glass-wrap {
            position: relative;
            width: 150px;
            height: 320px;
        }

        .glass {
            position: absolute;
            inset: 0;
            overflow: hidden;
            border-radius: 0 0 10px 10px;
            /* Subtle glass edges */
            border: 2px solid rgba(255,255,255,0.18);
            border-top: none;
            background: rgba(255,255,255,0.02);
        }

        /* Glass shine / reflection */
        .glass::after {
            content: '';
            position: absolute;
            top: 0;
            left: 14%;
            width: 12%;
            height: 100%;
            background: linear-gradient(180deg,
                rgba(255,255,255,0.07) 0%,
                rgba(255,255,255,0.02) 50%,
                transparent 80%
            );
            pointer-events: none;
            z-index: 20;
        }

        /* ─── LIQUID ─── */
        .liquid {
            position: absolute;
            /* Extends beyond glass bounds so rotation doesn't expose edges */
            bottom: -60px;
            left: -50%;
            width: 200%;
            /* Height set by JS */
            background: #1a1a1a;
            transform-origin: center center;
            z-index: 1;
            will-change: transform, height;
        }

        /* Foam head */
        .foam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            /* Height set by JS */
            background: linear-gradient(180deg,
                #f5edd6 0%,
                #ede1c8 20%,
                #ddd0b0 45%,
                #8a7a58 75%,
                #1a1a1a 100%
            );
            z-index: 2;
        }

        /* Subtle "carbonation" texture on the stout */
        .liquid::after {
            content: '';
            position: absolute;
            top: 30px;
            left: 25%;
            width: 50%;
            height: calc(100% - 30px);
            background: radial-gradient(
                ellipse 1px 1px at 20% 30%, rgba(255,255,255,0.04) 50%, transparent 50%
            ),
            radial-gradient(
                ellipse 1px 1px at 60% 50%, rgba(255,255,255,0.03) 50%, transparent 50%
            ),
            radial-gradient(
                ellipse 1px 1px at 40% 70%, rgba(255,255,255,0.04) 50%, transparent 50%
            );
            pointer-events: none;
        }

        /* ─── G LINE ─── */
        .g-line {
            position: absolute;
            bottom: 60%;
            left: -4px;
            right: -4px;
            z-index: 25;
            pointer-events: none;
        }
        .g-line-bar {
            width: 100%;
            height: 2px;
            background: #c8a84e;
            box-shadow: 0 0 8px rgba(200,168,78,0.35);
        }
        .g-label {
            position: absolute;
            right: -2px;
            top: -18px;
            font-size: 13px;
            font-weight: 800;
            color: #c8a84e;
            text-shadow: 0 0 6px rgba(200,168,78,0.3);
        }

        /* ════════════════════════════════════════
           SCORE SCREEN
           ════════════════════════════════════════ */
        .score-title {
            font-size: 2rem;
            font-weight: 800;
            color: #c8a84e;
            margin-bottom: 8px;
            text-align: center;
        }
        .score-subtitle {
            font-size: 0.85rem;
            color: #7a6a4a;
            margin-bottom: 36px;
        }

        .score-details {
            width: 100%;
            max-width: 260px;
            margin-bottom: 12px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(200,168,78,0.12);
            font-size: 0.95rem;
            color: #a09080;
        }
        .score-row:last-child { border-bottom: none; }
        .score-row.highlight {
            color: #c8a84e;
            font-weight: 700;
            font-size: 1.1rem;
        }
        .score-row span:last-child { font-variant-numeric: tabular-nums; }

        .accuracy-bar {
            width: 100%;
            max-width: 260px;
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            margin-bottom: 40px;
            overflow: hidden;
        }
        .accuracy-fill {
            height: 100%;
            width: 0%;
            border-radius: 3px;
            transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .accuracy-fill.gold { background: #c8a84e; }
        .accuracy-fill.green { background: #4ea84e; }
        .accuracy-fill.red { background: #a84e4e; }

        /* ════════════════════════════════════════
           MINI GLASS (Score screen preview)
           ════════════════════════════════════════ */
        .mini-glass-wrap {
            position: relative;
            width: 60px;
            height: 130px;
            margin-bottom: 30px;
        }
        .mini-glass {
            position: absolute;
            inset: 0;
            overflow: hidden;
            border-radius: 0 0 5px 5px;
            border: 1.5px solid rgba(255,255,255,0.15);
            border-top: none;
            background: rgba(255,255,255,0.02);
        }
        .mini-liquid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #1a1a1a;
            transition: height 0.6s ease;
        }
        .mini-foam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: linear-gradient(180deg, #f5edd6, #1a1a1a);
        }
        .mini-g-line {
            position: absolute;
            bottom: 60%;
            left: -3px;
            right: -3px;
            height: 1.5px;
            background: #c8a84e;
            z-index: 10;
        }
    </style>
</head>
<body>

    <!-- ═══════════════════════════════════════════
         START SCREEN
         ═══════════════════════════════════════════ -->
    <div id="screen-start" class="screen active">
        <h1 class="title">SPLIT THE G</h1>
        <div class="subtitle">The Pint Challenge</div>
        <div class="instructions">
            <p><span>1.</span> Hold your phone upright like a pint</p>
            <p><span>2.</span> Tap START, then tilt to "drink"</p>
            <p><span>3.</span> Return upright at the gold line</p>
            <p style="font-size:0.8rem;color:#605848;margin-top:8px">No gyroscope? Touch mode activates automatically — drag up to tilt.</p>
        </div>
        <button id="btn-start" class="btn btn-primary">START</button>
        <div class="sensor-info" id="sensor-info">Checking sensors...</div>
    </div>

    <!-- ═══════════════════════════════════════════
         GAME SCREEN
         ═══════════════════════════════════════════ -->
    <div id="screen-game" class="screen">
        <div class="hud">
            <div>Tilt: <span class="hud-val" id="hud-tilt">0</span>&deg;</div>
            <div>Level: <span class="hud-val" id="hud-level">100.0</span>%</div>
            <div>Raw: <span class="hud-val" id="hud-raw">—</span></div>
        </div>
        <div class="pour-indicator" id="pour-ind">POURING</div>
        <div class="glass-area">
            <div class="glass-wrap">
                <div class="glass">
                    <div id="liquid" class="liquid">
                        <div id="foam" class="foam"></div>
                    </div>
                </div>
                <div class="g-line">
                    <div class="g-line-bar"></div>
                    <span class="g-label">G</span>
                </div>
            </div>
        </div>
        <button id="btn-stop" class="btn btn-stop">DONE</button>
    </div>

    <!-- ═══════════════════════════════════════════
         SCORE SCREEN
         ═══════════════════════════════════════════ -->
    <div id="screen-score" class="screen">
        <h2 id="score-title" class="score-title"></h2>
        <div id="score-subtitle" class="score-subtitle"></div>
        <div class="mini-glass-wrap">
            <div class="mini-glass">
                <div id="mini-liquid" class="mini-liquid">
                    <div class="mini-foam"></div>
                </div>
            </div>
            <div class="mini-g-line"></div>
        </div>
        <div class="score-details">
            <div class="score-row">
                <span>Your level</span>
                <span id="s-level">—</span>
            </div>
            <div class="score-row">
                <span>Target</span>
                <span>60.0%</span>
            </div>
            <div class="score-row highlight">
                <span>Accuracy</span>
                <span id="s-accuracy">—</span>
            </div>
        </div>
        <div class="accuracy-bar">
            <div id="acc-fill" class="accuracy-fill gold"></div>
        </div>
        <button id="btn-retry" class="btn btn-primary">TRY AGAIN</button>
    </div>

    <script>
    (() => {
        'use strict';

        /* ════════════════════════════════════════════════════════
         * PHYSICS CONSTANTS — Tweak these to change the "feel"
         * ════════════════════════════════════════════════════════
         *
         * SPRING-DAMPER MODEL (Simple Harmonic Motion)
         * ────────────────────────────────────────────
         * The liquid surface angle follows a spring-damper system:
         *
         *   acceleration = SPRING_K * (target - current) - DAMPING_C * velocity
         *
         * This is NOT a 1:1 mapping of phone tilt to liquid angle.
         * Instead, the liquid "lags" behind the phone, overshoots
         * slightly, and wobbles before settling — like a real stout.
         *
         * Key derived values from the constants below:
         *   Natural frequency:  w0 = sqrt(K)   ≈ 12.2 rad/s  (~2 Hz)
         *   Damping ratio:      z  = C/(2*w0)  ≈ 0.74
         *
         *   z < 1 = underdamped  → wobbles before settling
         *   z = 1 = critically damped → fastest settle, no wobble
         *   z > 1 = overdamped  → sluggish, no wobble
         *
         *   Current setting (z ≈ 0.74): slightly underdamped.
         *   You get a subtle, heavy wobble — like a thick stout, not water.
         *
         * TO MAKE IT FEEL HEAVIER:  decrease K (slower response)
         * TO MAKE IT WOBBLIER:      decrease C (less friction)
         * TO MAKE IT SNAPPIER:      increase K (faster response)
         * TO KILL THE WOBBLE:       increase C past 2*sqrt(K) ≈ 24.5
         */
        const SPRING_K  = 150;   // Spring stiffness (higher = snappier)
        const DAMPING_C = 18;    // Damping friction (higher = less wobble)

        /* POURING BEHAVIOUR
         * ─────────────────
         * Liquid only flows when tilt exceeds POUR_THRESHOLD.
         * Flow rate scales linearly from 0 at threshold to
         * MAX_POUR_RATE at MAX_TILT. Beyond MAX_TILT, rate is capped.
         */
        const POUR_THRESHOLD = 20;  // degrees before liquid starts flowing
        const MAX_POUR_RATE  = 30;  // % of glass per second at max tilt
        const MAX_TILT       = 70;  // degrees — tilt ceiling for pour rate

        /* VISUAL LIMITS */
        const MAX_SURFACE_ANGLE = 15;  // max visual rotation (degrees)
        const FOAM_HEIGHT_MAX   = 28;  // max foam band height (px)
        const GLASS_HEIGHT      = 320; // must match CSS .glass-wrap height
        const LIQUID_BOTTOM_PAD = 60;  // must match CSS .liquid bottom offset

        /* GAME RULES */
        const TARGET_LEVEL     = 60;   // the "G" line (% from bottom)
        const SETTLE_THRESHOLD = 8;    // degrees — considered "upright"
        const SETTLE_TIME      = 1.0;  // seconds upright after pouring → auto-stop

        /* ════════════════════════════════════════════════════════
         * STATE
         * ════════════════════════════════════════════════════════ */
        let state          = 'idle';  // idle | playing | scored
        let initialBeta    = 90;      // calibrated "upright" beta
        let currentBeta    = 90;      // latest sensor reading

        let liquidLevel    = 100;     // 0–100 (% full)
        let surfaceAngle   = 0;       // current spring-damper angle
        let surfaceVel     = 0;       // angular velocity

        let hasPouredAny   = false;
        let uprightTimer   = 0;
        let lastTime       = 0;
        let rafId          = null;
        let sensorsReady   = false;

        /* ════════════════════════════════════════════════════════
         * DOM REFERENCES
         * ════════════════════════════════════════════════════════ */
        const $ = (id) => document.getElementById(id);

        const screens = {
            start: $('screen-start'),
            game:  $('screen-game'),
            score: $('screen-score'),
        };

        const dom = {
            btnStart:   $('btn-start'),
            btnStop:    $('btn-stop'),
            btnRetry:   $('btn-retry'),
            liquid:     $('liquid'),
            foam:       $('foam'),
            hudTilt:    $('hud-tilt'),
            hudLevel:   $('hud-level'),
            hudRaw:     $('hud-raw'),
            pourInd:    $('pour-ind'),
            sensorInfo: $('sensor-info'),
            scoreTitle: $('score-title'),
            scoreSub:   $('score-subtitle'),
            sLevel:     $('s-level'),
            sAccuracy:  $('s-accuracy'),
            accFill:    $('acc-fill'),
            miniLiquid: $('mini-liquid'),
        };

        /* ════════════════════════════════════════════════════════
         * SENSOR HANDLING
         * ════════════════════════════════════════════════════════
         *
         * Strategy:
         *   1. On START (user gesture), request iOS permission if needed
         *   2. Attach deviceorientation listener
         *   3. Wait up to 800ms to VERIFY we get actual readings
         *   4. If no readings arrive, fall back to touch-drag control
         *   5. Game always starts — never blocks on sensor failure
         */

        let sensorMode = 'none'; // 'gyro' | 'touch' | 'none'
        let gotSensorReading = false;

        function onOrientation(e) {
            if (e.beta !== null) {
                currentBeta = e.beta;
                gotSensorReading = true;
                sensorsReady = true;
            }
        }

        /**
         * Try to activate device orientation sensors.
         * Must be called from a user gesture (for iOS permission).
         * Returns true once sensors OR touch fallback are ready.
         */
        async function initSensors() {
            // Already working from a previous round
            if (sensorMode === 'gyro' && gotSensorReading) return true;
            if (sensorMode === 'touch') return true;

            // ── Step 1: iOS 13+ permission request ──
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const perm = await DeviceOrientationEvent.requestPermission();
                    if (perm !== 'granted') {
                        enableTouchFallback('Motion permission denied — using touch.');
                        return true;
                    }
                } catch (err) {
                    enableTouchFallback('Sensor error — using touch controls.');
                    return true;
                }
            }

            // ── Step 2: Attach listener ──
            if (typeof DeviceOrientationEvent !== 'undefined') {
                gotSensorReading = false;
                window.addEventListener('deviceorientation', onOrientation);

                // ── Step 3: Wait to verify real data arrives ──
                await sleep(800);

                if (gotSensorReading) {
                    sensorMode = 'gyro';
                    dom.sensorInfo.textContent = 'Sensors active.';
                    return true;
                }

                // Sensors exist in API but aren't delivering data
                window.removeEventListener('deviceorientation', onOrientation);
            }

            // ── Step 4: Fallback ──
            enableTouchFallback('No sensor data — using touch controls.');
            return true;
        }

        /**
         * Touch/mouse fallback: drag finger up to tilt, down for upright.
         * Works on any device — desktop or mobile without gyroscope.
         */
        function enableTouchFallback(msg) {
            if (sensorMode === 'touch') return; // already set up
            sensorMode = 'touch';
            sensorsReady = true;
            dom.sensorInfo.textContent = msg || 'Touch mode active.';

            const update = (clientY) => {
                // Bottom of screen = upright (beta 90), top = tilted (beta 20)
                const norm = 1 - (clientY / window.innerHeight);
                currentBeta = 90 - norm * 70;
            };

            document.addEventListener('mousemove', (e) => update(e.clientY));
            document.addEventListener('touchmove', (e) => {
                update(e.touches[0].clientY);
            }, { passive: true });
        }

        // Neutral message on page load — don't probe sensors yet
        dom.sensorInfo.textContent = 'Tap START to begin.';

        /* ════════════════════════════════════════════════════════
         * GAME LIFECYCLE
         * ════════════════════════════════════════════════════════ */

        async function startGame() {
            dom.btnStart.disabled = true;
            dom.btnStart.textContent = 'CONNECTING...';

            const ok = await initSensors();
            if (!ok) return;

            dom.btnStart.disabled = false;
            dom.btnStart.textContent = 'START';

            // *** CALIBRATION ***
            // Whatever angle the phone is at RIGHT NOW becomes "upright" (0°).
            // This is the crucial fix for the 80-85° "not quite 90" problem.
            initialBeta = currentBeta;

            // Reset state
            liquidLevel  = 100;
            surfaceAngle = 0;
            surfaceVel   = 0;
            hasPouredAny = false;
            uprightTimer = 0;

            state = 'playing';
            showScreen('game');
            render(false);

            // Request screen wake lock (best-effort, no error if unsupported)
            requestWakeLock();

            lastTime = performance.now();
            rafId = requestAnimationFrame(tick);
        }

        /**
         * Main game loop.
         * Runs every frame via requestAnimationFrame.
         */
        function tick(now) {
            if (state !== 'playing') return;

            // Delta time in seconds, capped to 50ms to prevent physics explosion
            // if tab was backgrounded or frame dropped badly
            const dt = Math.min((now - lastTime) / 1000, 0.05);
            lastTime = now;

            // ── Calibrated tilt ──
            // rawTilt is signed: negative = tilting top toward you (drinking),
            //                    positive = tilting top away from you.
            // We use Math.abs so pouring works in EITHER direction — the natural
            // drinking motion (top toward you) decreases beta, which was the
            // original bug (the old code only responded to increasing beta).
            const rawTilt = currentBeta - initialBeta;
            const tilt = clamp(Math.abs(rawTilt), 0, MAX_TILT);
            const tiltSign = rawTilt >= 0 ? 1 : -1;

            // ── Spring-Damper physics for liquid surface ──
            // Target is where the surface WANTS to be (proportional to tilt).
            // tiltSign preserves the visual wobble direction.
            const target = tiltSign * (tilt / MAX_TILT) * MAX_SURFACE_ANGLE;

            // Spring pulls surface toward target, damping resists velocity
            const springForce  =  SPRING_K * (target - surfaceAngle);
            const dampingForce = -DAMPING_C * surfaceVel;
            const accel = springForce + dampingForce;

            surfaceVel   += accel * dt;
            surfaceAngle += surfaceVel * dt;

            // ── Pouring ──
            let isPouring = false;
            if (tilt > POUR_THRESHOLD && liquidLevel > 0) {
                isPouring = true;
                hasPouredAny = true;

                // Flow rate scales linearly from 0 at threshold to MAX at MAX_TILT
                const pourFraction = (tilt - POUR_THRESHOLD) / (MAX_TILT - POUR_THRESHOLD);
                const rate = MAX_POUR_RATE * clamp(pourFraction, 0, 1);
                liquidLevel = Math.max(0, liquidLevel - rate * dt);
            }

            // ── Auto-stop detection ──
            // If the user has poured at least some, and returns to upright
            // for SETTLE_TIME seconds, the round ends automatically.
            if (hasPouredAny && tilt < SETTLE_THRESHOLD) {
                uprightTimer += dt;
                if (uprightTimer >= SETTLE_TIME) {
                    endGame();
                    return;
                }
            } else {
                uprightTimer = 0;
            }

            // ── Render ──
            render(isPouring);

            // Update HUD
            dom.hudTilt.textContent  = tilt.toFixed(0);
            dom.hudLevel.textContent = liquidLevel.toFixed(1);
            dom.hudRaw.textContent   = currentBeta.toFixed(0);

            rafId = requestAnimationFrame(tick);
        }

        function endGame() {
            state = 'scored';
            if (rafId) { cancelAnimationFrame(rafId); rafId = null; }

            const diff     = Math.abs(liquidLevel - TARGET_LEVEL);
            const accuracy = Math.max(0, 100 - diff * 2.5);

            // Title & subtitle based on performance
            let title, sub;
            if (diff <= 0.5)       { title = 'PERFECT SPLIT!';  sub = 'Absolutely nailed it.'; }
            else if (diff <= 2)    { title = 'INCREDIBLE!';     sub = 'Surgeon-level precision.'; }
            else if (diff <= 5)    { title = 'GREAT SPLIT!';    sub = 'Proper pub skills.'; }
            else if (diff <= 10)   { title = 'GOOD EFFORT';     sub = 'Getting there.'; }
            else if (diff <= 20)   { title = 'NOT BAD';         sub = 'Room for improvement.'; }
            else if (liquidLevel > TARGET_LEVEL) {
                                     title = 'DRINK MORE!';     sub = 'Didn\'t commit to the sip.'; }
            else                   { title = 'TOO GREEDY!';     sub = 'Left the G behind.'; }

            dom.scoreTitle.textContent = title;
            dom.scoreSub.textContent   = sub;
            dom.sLevel.textContent     = liquidLevel.toFixed(1) + '%';
            dom.sAccuracy.textContent  = accuracy.toFixed(0) + '%';

            // Accuracy bar colour
            dom.accFill.className = 'accuracy-fill ' +
                (accuracy >= 90 ? 'green' : accuracy >= 50 ? 'gold' : 'red');

            // Mini glass preview
            dom.miniLiquid.style.height = liquidLevel + '%';

            // Animate accuracy bar (set to 0 first, then expand)
            dom.accFill.style.width = '0%';
            showScreen('score');
            requestAnimationFrame(() => {
                dom.accFill.style.width = accuracy.toFixed(0) + '%';
            });
        }

        function resetGame() {
            state = 'idle';
            dom.btnStart.disabled = false;
            dom.btnStart.textContent = 'START';
            showScreen('start');
        }

        /* ════════════════════════════════════════════════════════
         * RENDERING
         * ════════════════════════════════════════════════════════ */

        function render(isPouring) {
            // Liquid div height = visible portion + bottom padding
            const px = (liquidLevel / 100) * GLASS_HEIGHT + LIQUID_BOTTOM_PAD;
            dom.liquid.style.height    = px + 'px';
            dom.liquid.style.transform = 'rotate(' + surfaceAngle.toFixed(2) + 'deg)';

            // Foam thins out below 25% fill
            const foamH = FOAM_HEIGHT_MAX * clamp(liquidLevel / 25, 0, 1);
            dom.foam.style.height = foamH + 'px';

            // Pour indicator
            if (isPouring) {
                dom.pourInd.classList.add('visible');
            } else {
                dom.pourInd.classList.remove('visible');
            }
        }

        /* ════════════════════════════════════════════════════════
         * SCREEN MANAGEMENT
         * ════════════════════════════════════════════════════════ */

        function showScreen(name) {
            for (const key in screens) {
                screens[key].classList.toggle('active', key === name);
            }
        }

        /* ════════════════════════════════════════════════════════
         * UTILITIES
         * ════════════════════════════════════════════════════════ */

        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
        function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    await navigator.wakeLock.request('screen');
                }
            } catch (_) { /* best effort */ }
        }

        /* ════════════════════════════════════════════════════════
         * EVENT LISTENERS
         * ════════════════════════════════════════════════════════ */

        dom.btnStart.addEventListener('click', startGame);
        dom.btnStop.addEventListener('click', () => {
            if (state === 'playing') endGame();
        });
        dom.btnRetry.addEventListener('click', resetGame);

        // Prevent pull-to-refresh during gyro play (but allow touch fallback moves)
        document.addEventListener('touchmove', (e) => {
            if (state === 'playing' && sensorMode === 'gyro') e.preventDefault();
        }, { passive: false });

        // Prevent double-tap zoom
        document.addEventListener('dblclick', (e) => e.preventDefault());

    })();
    </script>
</body>
</html>
