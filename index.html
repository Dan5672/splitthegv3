<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Split the G</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #0d0d0d;
            color: #e0d6c2;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* ════════════════════════════════════════
           SCREENS
           ════════════════════════════════════════ */
        .screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 24px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        .screen.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* ════════════════════════════════════════
           VERSION FOOTER (all screens)
           ════════════════════════════════════════ */
        .version {
            position: fixed;
            bottom: 6px;
            right: 10px;
            font-size: 0.6rem;
            color: #3a3228;
            z-index: 100;
            pointer-events: none;
        }

        /* ════════════════════════════════════════
           START SCREEN
           ════════════════════════════════════════ */
        .title {
            font-size: 2.5rem;
            font-weight: 800;
            color: #c8a84e;
            letter-spacing: 0.04em;
        }
        .subtitle {
            font-size: 0.8rem;
            color: #7a6a4a;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 40px;
        }
        .instructions {
            line-height: 2.2;
            font-size: 0.95rem;
            color: #a09080;
            margin-bottom: 40px;
            text-align: left;
        }
        .instructions span {
            color: #c8a84e;
            font-weight: 700;
        }
        .sensor-info {
            margin-top: 24px;
            font-size: 0.7rem;
            color: #706850;
            text-align: center;
            min-height: 2.5em;
        }

        /* ════════════════════════════════════════
           BUTTONS
           ════════════════════════════════════════ */
        .btn {
            padding: 16px 52px;
            font-size: 1.05rem;
            font-weight: 700;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 0.1em;
            transition: transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; }

        .btn-primary {
            background: linear-gradient(135deg, #d4b050, #a08030);
            color: #1a1408;
            box-shadow: 0 4px 24px rgba(200, 168, 78, 0.25);
        }
        .btn-stop {
            background: transparent;
            border: 2px solid rgba(200, 168, 78, 0.5);
            color: #c8a84e;
            padding: 14px 44px;
            font-size: 0.95rem;
        }

        /* ════════════════════════════════════════
           GAME SCREEN
           ════════════════════════════════════════ */
        #screen-game {
            justify-content: flex-start;
            padding-top: 20px;
            padding-bottom: 30px;
        }

        .hud {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 24px;
            font-size: 0.8rem;
            color: #7a6a4a;
            font-variant-numeric: tabular-nums;
            margin-bottom: 4px;
            flex-shrink: 0;
        }
        .hud-val { color: #c8a84e; font-weight: 600; }

        /* Debug panel — visible during gameplay for diagnostics */
        .debug {
            width: 100%;
            padding: 6px 12px;
            background: rgba(200,168,78,0.06);
            border-radius: 6px;
            font-size: 0.65rem;
            color: #8a7a5a;
            font-family: monospace;
            line-height: 1.6;
            text-align: center;
            margin-bottom: 4px;
            flex-shrink: 0;
        }

        .pour-indicator {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.25em;
            color: #c8a84e;
            height: 18px;
            opacity: 0;
            transition: opacity 0.15s;
            flex-shrink: 0;
        }
        .pour-indicator.visible { opacity: 1; }

        .glass-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            min-height: 0;
        }

        /* ─── THE GLASS ─── */
        .glass-wrap {
            position: relative;
            width: 150px;
            height: 320px;
        }

        .glass {
            position: absolute;
            inset: 0;
            overflow: hidden;
            border-radius: 0 0 10px 10px;
            border: 2px solid rgba(255,255,255,0.18);
            border-top: none;
            background: rgba(255,255,255,0.02);
        }

        /* Glass shine / reflection */
        .glass::after {
            content: '';
            position: absolute;
            top: 0;
            left: 14%;
            width: 12%;
            height: 100%;
            background: linear-gradient(180deg,
                rgba(255,255,255,0.07) 0%,
                rgba(255,255,255,0.02) 50%,
                transparent 80%
            );
            pointer-events: none;
            z-index: 20;
        }

        /* ─── LIQUID ─── */
        .liquid {
            position: absolute;
            bottom: -60px;
            left: -50%;
            width: 200%;
            background: #1a1a1a;
            transform-origin: center center;
            z-index: 1;
            will-change: transform, height;
        }

        /* Foam head */
        .foam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(180deg,
                #f5edd6 0%,
                #ede1c8 20%,
                #ddd0b0 45%,
                #8a7a58 75%,
                #1a1a1a 100%
            );
            z-index: 2;
        }

        /* Subtle "carbonation" texture on the stout */
        .liquid::after {
            content: '';
            position: absolute;
            top: 30px;
            left: 25%;
            width: 50%;
            height: calc(100% - 30px);
            background: radial-gradient(
                ellipse 1px 1px at 20% 30%, rgba(255,255,255,0.04) 50%, transparent 50%
            ),
            radial-gradient(
                ellipse 1px 1px at 60% 50%, rgba(255,255,255,0.03) 50%, transparent 50%
            ),
            radial-gradient(
                ellipse 1px 1px at 40% 70%, rgba(255,255,255,0.04) 50%, transparent 50%
            );
            pointer-events: none;
        }

        /* ─── G LINE ─── */
        .g-line {
            position: absolute;
            bottom: 60%;
            left: -4px;
            right: -4px;
            z-index: 25;
            pointer-events: none;
        }
        .g-line-bar {
            width: 100%;
            height: 2px;
            background: #c8a84e;
            box-shadow: 0 0 8px rgba(200,168,78,0.35);
        }
        .g-label {
            position: absolute;
            right: -2px;
            top: -18px;
            font-size: 13px;
            font-weight: 800;
            color: #c8a84e;
            text-shadow: 0 0 6px rgba(200,168,78,0.3);
        }

        /* ════════════════════════════════════════
           SCORE SCREEN
           ════════════════════════════════════════ */
        .score-title {
            font-size: 2rem;
            font-weight: 800;
            color: #c8a84e;
            margin-bottom: 8px;
            text-align: center;
        }
        .score-subtitle {
            font-size: 0.85rem;
            color: #7a6a4a;
            margin-bottom: 36px;
        }

        .score-details {
            width: 100%;
            max-width: 260px;
            margin-bottom: 12px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(200,168,78,0.12);
            font-size: 0.95rem;
            color: #a09080;
        }
        .score-row:last-child { border-bottom: none; }
        .score-row.highlight {
            color: #c8a84e;
            font-weight: 700;
            font-size: 1.1rem;
        }
        .score-row span:last-child { font-variant-numeric: tabular-nums; }

        .accuracy-bar {
            width: 100%;
            max-width: 260px;
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            margin-bottom: 40px;
            overflow: hidden;
        }
        .accuracy-fill {
            height: 100%;
            width: 0%;
            border-radius: 3px;
            transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .accuracy-fill.gold { background: #c8a84e; }
        .accuracy-fill.green { background: #4ea84e; }
        .accuracy-fill.red { background: #a84e4e; }

        /* ════════════════════════════════════════
           MINI GLASS (Score screen preview)
           ════════════════════════════════════════ */
        .mini-glass-wrap {
            position: relative;
            width: 60px;
            height: 130px;
            margin-bottom: 30px;
        }
        .mini-glass {
            position: absolute;
            inset: 0;
            overflow: hidden;
            border-radius: 0 0 5px 5px;
            border: 1.5px solid rgba(255,255,255,0.15);
            border-top: none;
            background: rgba(255,255,255,0.02);
        }
        .mini-liquid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #1a1a1a;
            transition: height 0.6s ease;
        }
        .mini-foam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: linear-gradient(180deg, #f5edd6, #1a1a1a);
        }
        .mini-g-line {
            position: absolute;
            bottom: 60%;
            left: -3px;
            right: -3px;
            height: 1.5px;
            background: #c8a84e;
            z-index: 10;
        }
    </style>
</head>
<body>

    <!-- VERSION FOOTER — always visible -->
    <div class="version" id="version">v0.4</div>

    <!-- ═══════════════════════════════════════════
         START SCREEN
         ═══════════════════════════════════════════ -->
    <div id="screen-start" class="screen active">
        <h1 class="title">SPLIT THE G</h1>
        <div class="subtitle">The Pint Challenge</div>
        <div class="instructions">
            <p><span>1.</span> Hold your phone upright like a pint</p>
            <p><span>2.</span> Tap START, then tilt to "drink"</p>
            <p><span>3.</span> Return upright at the gold line</p>
            <p style="font-size:0.8rem;color:#605848;margin-top:8px">No gyroscope? Touch mode activates automatically.</p>
        </div>
        <button id="btn-start" class="btn btn-primary">START</button>
        <div class="sensor-info" id="sensor-info">Tap START to begin.</div>
    </div>

    <!-- ═══════════════════════════════════════════
         GAME SCREEN
         ═══════════════════════════════════════════ -->
    <div id="screen-game" class="screen">
        <div class="hud">
            <div>Tilt: <span class="hud-val" id="hud-tilt">0</span>&deg;</div>
            <div>Level: <span class="hud-val" id="hud-level">100.0</span>%</div>
        </div>
        <div class="debug" id="debug">sensor: — | beta: — | init: — | events: 0</div>
        <div class="pour-indicator" id="pour-ind">POURING</div>
        <div class="glass-area">
            <div class="glass-wrap">
                <div class="glass">
                    <div id="liquid" class="liquid">
                        <div id="foam" class="foam"></div>
                    </div>
                </div>
                <div class="g-line">
                    <div class="g-line-bar"></div>
                    <span class="g-label">G</span>
                </div>
            </div>
        </div>
        <button id="btn-stop" class="btn btn-stop">DONE</button>
    </div>

    <!-- ═══════════════════════════════════════════
         SCORE SCREEN
         ═══════════════════════════════════════════ -->
    <div id="screen-score" class="screen">
        <h2 id="score-title" class="score-title"></h2>
        <div id="score-subtitle" class="score-subtitle"></div>
        <div class="mini-glass-wrap">
            <div class="mini-glass">
                <div id="mini-liquid" class="mini-liquid">
                    <div class="mini-foam"></div>
                </div>
            </div>
            <div class="mini-g-line"></div>
        </div>
        <div class="score-details">
            <div class="score-row">
                <span>Your level</span>
                <span id="s-level">—</span>
            </div>
            <div class="score-row">
                <span>Target</span>
                <span>60.0%</span>
            </div>
            <div class="score-row highlight">
                <span>Accuracy</span>
                <span id="s-accuracy">—</span>
            </div>
        </div>
        <div class="accuracy-bar">
            <div id="acc-fill" class="accuracy-fill gold"></div>
        </div>
        <button id="btn-retry" class="btn btn-primary">TRY AGAIN</button>
    </div>

    <script>
    (() => {
        'use strict';

        const VERSION = 'v0.4';

        /* ════════════════════════════════════════════════════════
         * PHYSICS CONSTANTS — Tweak these to change the "feel"
         * ════════════════════════════════════════════════════════
         *
         * SPRING-DAMPER MODEL (Simple Harmonic Motion)
         * ────────────────────────────────────────────
         * The liquid surface angle follows a spring-damper system:
         *
         *   acceleration = SPRING_K * (target - current) - DAMPING_C * velocity
         *
         * Key derived values:
         *   Natural frequency:  w0 = sqrt(K)   ≈ 12.2 rad/s  (~2 Hz)
         *   Damping ratio:      z  = C/(2*w0)  ≈ 0.74
         *
         *   z < 1 = underdamped (wobbles)  |  z = 1 = critical  |  z > 1 = overdamped
         *   Current (z ≈ 0.74) = subtle heavy wobble, like a thick stout.
         *
         * TO MAKE IT HEAVIER:  decrease K    TO MAKE IT WOBBLIER: decrease C
         * TO MAKE IT SNAPPIER: increase K    TO KILL WOBBLE:      increase C past ~24.5
         */
        const SPRING_K  = 150;
        const DAMPING_C = 18;

        /* POURING BEHAVIOUR */
        const POUR_THRESHOLD = 15;  // degrees before liquid starts flowing
        const MAX_POUR_RATE  = 30;  // % of glass per second at max tilt
        const MAX_TILT       = 70;  // degrees — tilt ceiling for pour rate

        /* VISUAL LIMITS */
        const MAX_SURFACE_ANGLE = 15;
        const FOAM_HEIGHT_MAX   = 28;
        const GLASS_HEIGHT      = 320;
        const LIQUID_BOTTOM_PAD = 60;

        /* GAME RULES */
        const TARGET_LEVEL     = 60;
        const SETTLE_THRESHOLD = 8;
        const SETTLE_TIME      = 1.0;

        /* ════════════════════════════════════════════════════════
         * STATE
         * ════════════════════════════════════════════════════════ */
        let state          = 'idle';
        let initialBeta    = 90;
        let currentBeta    = 90;

        let liquidLevel    = 100;
        let surfaceAngle   = 0;
        let surfaceVel     = 0;

        let hasPouredAny   = false;
        let uprightTimer   = 0;
        let lastTime       = 0;
        let rafId          = null;

        /* ════════════════════════════════════════════════════════
         * DOM REFERENCES
         * ════════════════════════════════════════════════════════ */
        const $ = (id) => document.getElementById(id);

        const screens = {
            start: $('screen-start'),
            game:  $('screen-game'),
            score: $('screen-score'),
        };

        const dom = {
            btnStart:   $('btn-start'),
            btnStop:    $('btn-stop'),
            btnRetry:   $('btn-retry'),
            liquid:     $('liquid'),
            foam:       $('foam'),
            hudTilt:    $('hud-tilt'),
            hudLevel:   $('hud-level'),
            debug:      $('debug'),
            pourInd:    $('pour-ind'),
            sensorInfo: $('sensor-info'),
            scoreTitle: $('score-title'),
            scoreSub:   $('score-subtitle'),
            sLevel:     $('s-level'),
            sAccuracy:  $('s-accuracy'),
            accFill:    $('acc-fill'),
            miniLiquid: $('mini-liquid'),
        };

        /* ════════════════════════════════════════════════════════
         * SENSOR HANDLING
         * ════════════════════════════════════════════════════════
         *
         * Strategy (in order of preference):
         *   1. DeviceOrientationEvent (standard gyro API)
         *   2. DeviceMotionEvent (derive tilt from accelerometer)
         *   3. Touch/mouse drag fallback
         *
         * Each step waits to VERIFY data actually arrives before
         * committing. The game always starts regardless.
         */

        let sensorMode      = 'none'; // 'orientation' | 'motion' | 'touch'
        let gotSensorReading = false;
        let sensorEventCount = 0;

        function onOrientation(e) {
            if (e.beta !== null) {
                currentBeta = e.beta;
                gotSensorReading = true;
                sensorEventCount++;
            }
        }

        function onDeviceMotion(e) {
            const g = e.accelerationIncludingGravity;
            if (g && g.y !== null && g.z !== null) {
                // Derive beta (tilt angle from flat) from accelerometer
                // Flat face-up = 0°, upright = 90°, flat face-down = 180°
                currentBeta = Math.atan2(g.y, g.z) * (180 / Math.PI);
                gotSensorReading = true;
                sensorEventCount++;
            }
        }

        async function initSensors() {
            // Already initialised from a previous round
            if (sensorMode !== 'none') return true;

            // ── iOS 13+ permission gate ──
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const perm = await DeviceOrientationEvent.requestPermission();
                    if (perm !== 'granted') {
                        enableTouchFallback('Motion permission denied — using touch.');
                        return true;
                    }
                } catch (err) {
                    enableTouchFallback('Permission error — using touch.');
                    return true;
                }
            }

            // ── Attempt 1: DeviceOrientationEvent ──
            if ('DeviceOrientationEvent' in window) {
                gotSensorReading = false;
                sensorEventCount = 0;
                window.addEventListener('deviceorientation', onOrientation);
                dom.sensorInfo.textContent = 'Trying orientation sensor...';
                await sleep(600);

                if (gotSensorReading) {
                    sensorMode = 'orientation';
                    dom.sensorInfo.textContent = 'Orientation sensor active (' + sensorEventCount + ' events).';
                    return true;
                }
                window.removeEventListener('deviceorientation', onOrientation);
            }

            // ── Attempt 2: DeviceMotionEvent (accelerometer fallback) ──
            if ('DeviceMotionEvent' in window) {
                gotSensorReading = false;
                sensorEventCount = 0;
                window.addEventListener('devicemotion', onDeviceMotion);
                dom.sensorInfo.textContent = 'Trying motion sensor...';
                await sleep(600);

                if (gotSensorReading) {
                    sensorMode = 'motion';
                    dom.sensorInfo.textContent = 'Motion sensor active (' + sensorEventCount + ' events).';
                    return true;
                }
                window.removeEventListener('devicemotion', onDeviceMotion);
            }

            // ── Attempt 3: Touch/mouse fallback ──
            enableTouchFallback('No sensors detected — using touch controls.');
            return true;
        }

        function enableTouchFallback(msg) {
            if (sensorMode === 'touch') return;
            sensorMode = 'touch';
            dom.sensorInfo.textContent = msg;

            const update = (clientY) => {
                // Bottom of screen = upright (beta 90), top = max tilt (beta 20)
                const norm = 1 - (clientY / window.innerHeight);
                currentBeta = 90 - norm * 70;
                sensorEventCount++;
            };

            document.addEventListener('mousemove', (e) => update(e.clientY));
            document.addEventListener('touchmove', (e) => {
                update(e.touches[0].clientY);
            }, { passive: true });
        }

        /* ════════════════════════════════════════════════════════
         * GAME LIFECYCLE
         * ════════════════════════════════════════════════════════ */

        async function startGame() {
            dom.btnStart.disabled = true;
            dom.btnStart.textContent = 'CONNECTING...';

            await initSensors();

            dom.btnStart.disabled = false;
            dom.btnStart.textContent = 'START';

            // *** CALIBRATION ***
            // Whatever angle the phone is at RIGHT NOW = "upright" (0°).
            initialBeta = currentBeta;

            // Reset state
            liquidLevel  = 100;
            surfaceAngle = 0;
            surfaceVel   = 0;
            hasPouredAny = false;
            uprightTimer = 0;

            state = 'playing';
            showScreen('game');
            render(false);
            requestWakeLock();

            lastTime = performance.now();
            rafId = requestAnimationFrame(tick);
        }

        /**
         * Main game loop — runs every frame.
         */
        function tick(now) {
            if (state !== 'playing') return;

            const dt = Math.min((now - lastTime) / 1000, 0.05);
            lastTime = now;

            // ── Calibrated tilt ──
            // Math.abs makes pouring work in EITHER tilt direction.
            // The natural drinking motion (tilt top toward you) decreases beta,
            // while tilting away increases it — both should work.
            const rawTilt  = currentBeta - initialBeta;
            const tilt     = clamp(Math.abs(rawTilt), 0, MAX_TILT);
            const tiltSign = rawTilt >= 0 ? 1 : -1;

            // ── Spring-Damper physics for liquid surface ──
            const target       = tiltSign * (tilt / MAX_TILT) * MAX_SURFACE_ANGLE;
            const springForce  =  SPRING_K * (target - surfaceAngle);
            const dampingForce = -DAMPING_C * surfaceVel;
            const accel        = springForce + dampingForce;

            surfaceVel   += accel * dt;
            surfaceAngle += surfaceVel * dt;

            // ── Pouring ──
            let isPouring = false;
            if (tilt > POUR_THRESHOLD && liquidLevel > 0) {
                isPouring = true;
                hasPouredAny = true;
                const pourFraction = (tilt - POUR_THRESHOLD) / (MAX_TILT - POUR_THRESHOLD);
                const rate = MAX_POUR_RATE * clamp(pourFraction, 0, 1);
                liquidLevel = Math.max(0, liquidLevel - rate * dt);
            }

            // ── Auto-stop detection ──
            if (hasPouredAny && tilt < SETTLE_THRESHOLD) {
                uprightTimer += dt;
                if (uprightTimer >= SETTLE_TIME) {
                    endGame();
                    return;
                }
            } else {
                uprightTimer = 0;
            }

            // ── Render ──
            render(isPouring);

            // ── HUD ──
            dom.hudTilt.textContent  = tilt.toFixed(0);
            dom.hudLevel.textContent = liquidLevel.toFixed(1);

            // ── Debug panel ──
            dom.debug.textContent =
                'mode: ' + sensorMode +
                ' | beta: ' + currentBeta.toFixed(1) +
                ' | init: ' + initialBeta.toFixed(1) +
                ' | raw: ' + rawTilt.toFixed(1) +
                ' | events: ' + sensorEventCount;

            rafId = requestAnimationFrame(tick);
        }

        function endGame() {
            state = 'scored';
            if (rafId) { cancelAnimationFrame(rafId); rafId = null; }

            const diff     = Math.abs(liquidLevel - TARGET_LEVEL);
            const accuracy = Math.max(0, 100 - diff * 2.5);

            let title, sub;
            if (diff <= 0.5)       { title = 'PERFECT SPLIT!';  sub = 'Absolutely nailed it.'; }
            else if (diff <= 2)    { title = 'INCREDIBLE!';     sub = 'Surgeon-level precision.'; }
            else if (diff <= 5)    { title = 'GREAT SPLIT!';    sub = 'Proper pub skills.'; }
            else if (diff <= 10)   { title = 'GOOD EFFORT';     sub = 'Getting there.'; }
            else if (diff <= 20)   { title = 'NOT BAD';         sub = 'Room for improvement.'; }
            else if (liquidLevel > TARGET_LEVEL) {
                                     title = 'DRINK MORE!';     sub = 'Didn\'t commit to the sip.'; }
            else                   { title = 'TOO GREEDY!';     sub = 'Left the G behind.'; }

            dom.scoreTitle.textContent = title;
            dom.scoreSub.textContent   = sub;
            dom.sLevel.textContent     = liquidLevel.toFixed(1) + '%';
            dom.sAccuracy.textContent  = accuracy.toFixed(0) + '%';

            dom.accFill.className = 'accuracy-fill ' +
                (accuracy >= 90 ? 'green' : accuracy >= 50 ? 'gold' : 'red');

            dom.miniLiquid.style.height = liquidLevel + '%';

            dom.accFill.style.width = '0%';
            showScreen('score');
            requestAnimationFrame(() => {
                dom.accFill.style.width = accuracy.toFixed(0) + '%';
            });
        }

        function resetGame() {
            state = 'idle';
            dom.btnStart.disabled = false;
            dom.btnStart.textContent = 'START';
            showScreen('start');
        }

        /* ════════════════════════════════════════════════════════
         * RENDERING
         * ════════════════════════════════════════════════════════ */

        function render(isPouring) {
            const px = (liquidLevel / 100) * GLASS_HEIGHT + LIQUID_BOTTOM_PAD;
            dom.liquid.style.height    = px + 'px';
            dom.liquid.style.transform = 'rotate(' + surfaceAngle.toFixed(2) + 'deg)';

            const foamH = FOAM_HEIGHT_MAX * clamp(liquidLevel / 25, 0, 1);
            dom.foam.style.height = foamH + 'px';

            if (isPouring) {
                dom.pourInd.classList.add('visible');
            } else {
                dom.pourInd.classList.remove('visible');
            }
        }

        /* ════════════════════════════════════════════════════════
         * SCREEN MANAGEMENT
         * ════════════════════════════════════════════════════════ */

        function showScreen(name) {
            for (const key in screens) {
                screens[key].classList.toggle('active', key === name);
            }
        }

        /* ════════════════════════════════════════════════════════
         * UTILITIES
         * ════════════════════════════════════════════════════════ */

        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
        function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    await navigator.wakeLock.request('screen');
                }
            } catch (_) { /* best effort */ }
        }

        /* ════════════════════════════════════════════════════════
         * EVENT LISTENERS
         * ════════════════════════════════════════════════════════ */

        dom.btnStart.addEventListener('click', startGame);
        dom.btnStop.addEventListener('click', () => {
            if (state === 'playing') endGame();
        });
        dom.btnRetry.addEventListener('click', resetGame);

        // Prevent pull-to-refresh during gyro play (but allow touch fallback)
        document.addEventListener('touchmove', (e) => {
            if (state === 'playing' && sensorMode !== 'touch') e.preventDefault();
        }, { passive: false });

        document.addEventListener('dblclick', (e) => e.preventDefault());

    })();
    </script>
</body>
</html>
